<html>
    <head>
        <title>FIDO2 Auth</title>
        <link rel="stylesheet" href="css/login-style.css">
        <script type="text/javascript" src="http://jqueryjs.googlecode.com/files/jquery-1.3.2.js"></script>
        <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    <script type="text/javascript">
        function browsercompact() {
            if (!window.PublicKeyCredential) {
                alert("public-key credentials not supported"); 
                return false
            }
           
        }
        window.onload = browsercompact;
        </script>
    </head>
    <body>

      <form action="/webauthn/authn">
        <div class="banner">
          <h1>FIDO2 Passwordless</h1>
        </div>
        <input type="hidden" name="action" id="action" value="2" />
        <input type="hidden" name="assertion" id="action" value="2" />
        <div class="btn-block">
          <button type="submit" onclick="activeyubikey()">Active an Yubikey</button>
        </div>
      </form>

<script type="text/javascript">

  var publicKeyCredentialCreationOptionsVal = "{\"rp\":{\"id\":\"LFDC9C66L63.1DC.com\",\"name\":\"PingFederate\"},\"user\":{\"id\":[-79,-102,19,31,22,117,-72,-34,58,-82,54,-38,-49,-101,-119,-80,118,-37,27,-16,101,71,-68,-105,92,17,-40,50,-109,89,-115,0],\"displayName\":\"jason.wang2@fiserv.com\",\"name\":\"jason.wang2@fiserv.com\"},\"challenge\":[26,27,42,65,118,-51,69,-34,-75,102,95,-78,56,-90,-97,44,21,16,65,84,55,94,54,-127,-113,-126,-44,98,-107,9,-61,-58],\"pubKeyCredParams\":[{\"type\":\"public-key\",\"alg\":\"-7\"},{\"type\":\"public-key\",\"alg\":\"-37\"},{\"type\":\"public-key\",\"alg\":\"-257\"}],\"timeout\":120000,\"excludeCredentials\":[],\"authenticatorSelection\":{\"authenticatorAttachment\":\"cross-platform\",\"residentKey\":\"required\",\"requireResidentKey\":true,\"userVerification\":\"preferred\"},\"attestation\":\"none\"}";

  alert ("publicKeyCredentialCreationOptions: " + publicKeyCredentialCreationOptionsVal);

  var attestation= Register(publicKeyCredentialCreationOptionsVal);

  alert ("attestation: " + attestation);

  function activeyubikey() {
	document.forms[0]['action'].value = "2";
	document.forms[0]['assertion'].value = attestation;
  }

  //=========

  var authAbortController = window.PublicKeyCredential ? new AbortController() : null;
	var authAbortSignal = window.PublicKeyCredential ? authAbortController.signal : null;

	window.abortWebAuthnSignal = function abortWebAuthnSignal() {
	    authAbortController.abort();
	    authAbortController = new AbortController();
	    authAbortSignal = authAbortController.signal;
	}

	window.IsWebAuthnSupported = function IsWebAuthnSupported() {
	    if (!window.PublicKeyCredential) {
	        console.log("Web Authentication API is not supported on this browser.");
	        return false;
	    }
	    return true;
	}

	window.isWebAuthnPlatformAuthenticatorAvailable = function isWebAuthnPlatformAuthenticatorAvailable() {
	    var timer;
	    var p1 = new Promise(function(resolve) {
	        timer = setTimeout(function() {
	            console.log("isWebAuthnPlatformAuthenticatorAvailable - Timeout");
	            resolve(false);
	        }, 1000);
	    });
	    var p2 = new Promise(function(resolve) {
	        if (IsWebAuthnSupported() && window.PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable) {
	            resolve(
		            window.PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable().catch(function(err) {
	                    console.log(err);
	                    return false;
	                }));
	        }
	        else {
	            resolve(false);
	        }
	    });
	    return Promise.race([p1, p2]).then(function (res) {
	        clearTimeout(timer);
	        console.log("isWebAuthnPlatformAuthenticatorAvailable - " +  res);
	        return res;
	    });
	}

	window.WebAuthnPlatformRegistration = function WebAuthnPlatformRegistration(publicKeyCredentialCreationOptions) {
	    return new Promise(function(resolve, reject) {
	        isWebAuthnPlatformAuthenticatorAvailable().then(function (result) {
	            if (result) {
	                resolve(Register(publicKeyCredentialCreationOptions));
	            }
	            reject(Error("UnSupportedBrowserError"));
	        });
	    });
	}

	function Register(publicKeyCredentialCreationOptions) {
		
		alert ("publicKeyCredentialCreationOptions +1 : " + publicKeyCredentialCreationOptions);
		
	    return new Promise(function(resolve, reject) {
	        var options = JSON.parse(publicKeyCredentialCreationOptions);
	        var publicKeyCredential = {};
	        publicKeyCredential.rp = options.rp;
	        publicKeyCredential.user = options.user;
	        publicKeyCredential.user.id = new Uint8Array(options.user.id);
	        publicKeyCredential.challenge = new Uint8Array(options.challenge);
	        publicKeyCredential.pubKeyCredParams = options.pubKeyCredParams;

	        alert ("publicKeyCredential.user.id : " + publicKeyCredential.user.id);
	        
	        // Optional parameters
	        if ('timeout' in options) {
	            publicKeyCredential.timeout = options.timeout;
	        }
	        if ('excludeCredentials' in options) {
	            publicKeyCredential.excludeCredentials = credentialListConversion(options.excludeCredentials);
	        }
	        if ('authenticatorSelection' in options) {
	            publicKeyCredential.authenticatorSelection = options.authenticatorSelection;
	        }
	        if ('attestation' in options) {
	            publicKeyCredential.attestation = options.attestation;
	        }
	        if ('extensions' in options) {
	            publicKeyCredential.extensions = options.extensions;
	        }
	        console.log(publicKeyCredential);
	        
	        alert ("publicKeyCredential : " + publicKeyCredential);
	        
	        alert ("authAbortSignal : " + authAbortSignal);
	        
	        navigator.credentials.create({"publicKey": publicKeyCredential, "signal": authAbortSignal})
	            .then(function (newCredentialInfo) {
	                // Send new credential info to server for verification and registration.

	    	        alert ("publicKeyCredential : ");
	                
	                console.log(newCredentialInfo);
	                var publicKeyCredential = {};
	                
	                if ('id' in newCredentialInfo) {
	                    publicKeyCredential.id = newCredentialInfo.id;
	                }
	                
	                alert("id in newCredentialInfo.");
	                
	                if ('type' in newCredentialInfo) {
	                    publicKeyCredential.type = newCredentialInfo.type;
	                }
	                
	                alert("type in newCredentialInfo.");
	                
	                
	                if ('rawId' in newCredentialInfo) {
	                    publicKeyCredential.rawId = toBase64Str(newCredentialInfo.rawId);
	                }
	                alert("rawId in newCredentialInfo.");
	                
	                
	                if (!newCredentialInfo.response) {
	                    throw "Missing 'response' attribute in credential response";
	                }
	                
	                alert("Prepare response.");
	                
	                var response = {};
	                response.clientDataJSON = toBase64Str(newCredentialInfo.response.clientDataJSON);
	                response.attestationObject = toBase64Str(newCredentialInfo.response.attestationObject);
	                publicKeyCredential.response = response;
	                resolve(JSON.stringify(publicKeyCredential));
	            }).catch(function (err) {
	            	alert("err: " + err);
	                // No acceptable authenticator or user refused consent. Handle appropriately.
	                console.log(err);
	                reject(Error(err.name));
	        });
	    });
	}

	function credentialListConversion(list) {
	    var credList = [];
	    for (var i=0; i < list.length; i++) {
	        var cred = {
	            type: list[i].type,
	            id: new Uint8Array(list[i].id)
	        };
	        if (list[i].transports) {
	            cred.transports = list[i].transports;
	        }
	        credList.push(cred);
	    }
	    return credList;
	}

	function toBase64Str(bin){
	    return btoa(String.fromCharCode.apply(null, new Uint8Array(bin)));
	}

</script>
</body>
</html>